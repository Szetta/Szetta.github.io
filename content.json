{"meta":{"title":"Szetta - blog","subtitle":null,"description":null,"author":"Szetta","url":"http://yoursite.com","root":"/"},"pages":[{"title":"'tags'","date":"2020-06-14T06:58:41.000Z","updated":"2020-06-14T06:59:00.091Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"目录","date":"2020-06-13T13:21:05.000Z","updated":"2020-06-14T07:09:41.140Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript的变量、作用域与内存问题","slug":"JavaScript的变量、作用域与内存问题","date":"2020-06-13T13:25:38.000Z","updated":"2020-06-14T14:15:03.016Z","comments":true,"path":"2020/06/13/JavaScript的变量、作用域与内存问题/","link":"","permalink":"http://yoursite.com/2020/06/13/JavaScript的变量、作用域与内存问题/","excerpt":"包括基本类型和引用类型的值、变量作用域与垃圾收集机制","text":"包括基本类型和引用类型的值、变量作用域与垃圾收集机制 基本类型与引用类型","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[]},{"title":"JavaScript的基本概念","slug":"JavaScript的基本概念","date":"2020-06-13T13:10:38.000Z","updated":"2020-06-20T14:23:24.438Z","comments":true,"path":"2020/06/13/JavaScript的基本概念/","link":"","permalink":"http://yoursite.com/2020/06/13/JavaScript的基本概念/","excerpt":"包括Javascript变量、数据类型、操作符、函数等基本概念。","text":"包括Javascript变量、数据类型、操作符、函数等基本概念。 变量ECMAScript的变量是松散类型的，即可以用来保存任何类型的数据。每个变量仅仅是一个用于保存值的占位符。这意味着在定义变量时，我们不需要指定该变量的类型。在JavaScript中，我们可以用 var 操作符定义一个变量名。如：1var message = \"Hello, JavaScript!\"; 在ECMAScript6中，声明变量的操作符新增了 let 和 const 类型。使用这两个操作符声明的变量仅在其所在的代码块里生效。其中，const 声明的变量是常量。一旦声明后则不能改变，所以所有的 const 变量都需要在声明时进行初始化；而 let 声明的变量值可以改变。如：12345678&#123; let num1 = \"let\"; const num2 = \"const\"; var num3 = \"var\";&#125;console.log(num1); // Error: num1 is not definedconsole.log(num2); // Error: num2 is not definedconsole.log(num3); 数据类型ECMAScript中有5种基本数据类型及1种复杂数据类型。5种基本数据类型：Undefined 、Null 、Boolean 、Number和 String。1种负责数据类型：Object。由于ECMAScript是松散类型的，所以需要一种方法来检测给定变量的数据类型，即typeof操作符，如：12const message = \"str\";console.log(typeof message); // Output:\"string\" typeof操作符返回值有以下六个：undefined、boolean、string、number、object、function可以注意到在返回值中，并不包含基本数据类型中的 null。这是因为 null 值被认为是一个空对象的引用，所以返回值应为”object”。 基本数据类型Undefined类型如果使用 var、let 声明了一个变量但未对其初始化时，这个变量的值就是 undefined，也可以显式地将某一个变量的值设置为 undefined。对于 const 操作符，不允许用户在声明变量时不对其进行初始化。如：123456var message1;var message1 = undefined;const message2; // Error: Missing initializer in const declarationconst message3 = undefined;let message4;let message5 = undefined; 对于尚未声明的变量，只能用 typeof 操作符对其进行检测（返回值为undefined），而不能执行其他任何操作。 建议在声明变量时就对其进行初始化。如此在使用 typeof 操作符返回”undefined”时，我们就能正确区分该值是未被声明，而不是未被初始化。 Null类型null值表示一个空对象指针，所以使用 typeof 操作符检测 null 值时会返回 “object”。如果定义的变量将用于保存对象，那么最好将该变量初始化为 null 。这样只要直接检查 null 值就可以知道变量是否已经保存了一个对象的引用，如：1234let message = null;if(message !== null)&#123; console.log(\"Message is not null!\");&#125; 如果使用”==”（Equality）检测 null 和 undefined，会得到 true。这是因为这个操作符在对变量进行比较是会对其进行转换（可以尝试检测”1”==1，输出结果也是 ture），而 undefined 值是派生自 null 值的，所以在相等性检测时会输出 null。 Boolean类型Boolean类型只有两个字面值： true 和 false。ECMAScript中所有类型的值都可以转换为对应 数据类型 转换为true的值 转换为false的值 String 任何非空字符串 “” （空字符串） Number 任何非零数字值（包括无穷大） 0和NaN Object 任何对象 null Undefined 无 undefined Number类型Number类型类型使用 IEEE754 格式来表示整数和浮点数值。数值类型有：十进制数、八进制数、十六进制数。 十进制数：最基本的数值类型 八进制：第一位必须是0，后跟范围在0~7的数字序列。若序列中有数字超出该范围，则将会被当作十进制解析 十六进制：第一位必须是0x，后跟范围在（0~9、A~F）的数字序列。若序列中有数字超出该范围，则会报错。 123console.log(071); // Output: 57console.log(0x123); // Output: 291console.log(0x3EG); // Error: Invalid or unexpected token 在进行算术运算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数。1. 浮点数值浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字。由于保存浮点数值需要的内存空间是保存整数值的两倍，因此 ECMAScript在小数点后仅有一位数字0的情况下，会将数字转换为整数值已节约内存空间，如10.0。对于那些极大或极小的数值，可以用科学计数法（e表示法）进行表示。用 e 表示法表示的数值等于 e 前面的数值乘以 10 的指数次幂，如： 123console.log(2.5e7); // Output: 25000000console.log(2.5e-3); // Output: 0.0025console.log(2.5e-3.5); // Error: missing ) after argument list 浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。例如，0.1 加 0.2的结果不是 0.3，而是 0.30000000000000004。这是因为在有限的存储空间下，绝大部分的十进制小数都不能用二进制浮点数来精确表示。这个小小的舍入误差会导致无法测试特定的浮点数值。如: 1console.log(0.1+0.2===0.3); // Output: false 如果你确实需要对小数点进行精确处理，比如在处理钱款交易时，可以使用特殊的十进制数据类型 BigDecimal。如果你只是不想看到所有这些多余的小数位，只需在显示结果时将其格式四舍五入为固定的小数位数即可。 2. 数值范围 JavaScript使用标准的8字节IEEE浮点数字格式。ECMAScript 能够表示的最小数值保存在 Number.MIN_VALUE 中——在大多数浏览器中，这个值是 5e-324；能够表示的最大数值保存在Number.MAX_VALUE 中——在大多数浏览器中，这个值是 1.7976931348623157e+308。由于JavaScript使用浮点数，因此只能保证-9007199254740992（-2 ^ 53）和9007199254740992（2 ^ 53）之间的整数的准确性。如果某次计算的结果得到了一个超出 JavaScript 数值范围的值，那么这个数值将被自动转换成特殊的 -Infinity/+Infinity 值。 如果某次计算返回的是 Infinity 值，那么该值将无法继续参与下一次的计算。如果想确定一个数值是不是有穷的，可以使用 isFinite() 函数。 3. NaN NaN（Not a Number）数值用于表示一个本来要返回数值的操作数未返回数值的情况，以避免抛出错误。在 ECMAScript中，在 0 除以 0 的情况下会返回 NaN。 任何涉及 NaN 的操作（例如 NaN /10）都会返回 NaN。 NaN 与任何值也都不相等，包括 NaN 本身。所以，ECMAScript 提供了 isNaN() 函数已检测参数是不是数值以及是否能够被转换为数值。 123console.log(isNaN(1)); // Output: falseconsole.log(isNaN(\"1\")); // Output: falseconsole.log(isNaN(&#123;value:1&#125;)); // Output: true 4. 数值转换 有 3 个函数可以把非数值转换为数值： Number() 、 parseInt() 和 parseFloat() 。 Number(): 可以用于任何数据类型 如果是 Boolean 值， true 和 false 将分别被转换为 1 和 0。 如果是 null 值，返回 0。 如果是 undefined ，返回 NaN 。 如果字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值。 如果字符串中包含有效的浮点格式，如 “1.1” ，则将其转换为对应的浮点数值。 如果字符串中包含有效的十六进制格式，例如 “0xf” ，则将其转换为相同大小的十进制整数值。（如果包含先导0，则不会转化为八进制，而是忽略0，转化为十进制） 如果字符串是空的（不包含任何字符），则将其转换为 0； 如果字符串中包含除上述格式之外的字符，则将其转换为 NaN 。 如果是对象，则调用对象的 valueOf() 方法，然后依照前面的规则转换返回的值。如果转换的结果是 NaN ，则调用对象的 toString() 方法，然后再次依照前面的规则转换返回的字符串值。 parseInt() 函数：专门用于把字符串转换成整数数值。该函数会忽略字符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号， parseInt()就会返回 NaN。如果第一个字符是数字字符或负号， parseInt() 会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。 1234// parseInt()函数第二个参数用于指定进制console.log(parseInt(\"123test\",10)); // Output: 123console.log(parseInt(\"123test\",8)); // Output: 83console.log(parseInt(\"123Atest\",16)); // Output: 4666 parseFloat() 函数：与 parseInt() 类似，该函数也是从第一个字符（位置 0）开始解析每个字符。而且也是一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止。 String类型String 类型用于表示由零或多个 16 位 Unicode 字符组成的字符序列，即字符串。字符串可以由双引号（”）或单引号（’）表示。String 数据类型包含一些特殊的字符字面量，也叫转义序列，用于表示非打印字符，或者具有其他用途的字符。这些字符字面量可以作为一个字符来解析。1console.log(\"\\u03a3\".length); // Output: 1 任何字符串的长度都可以通过 length 属性获取。如果字符串中包含双字节字符，那么 length 属性可能不会精确地返回字符串中的字符数目，在处理中文长度时需要特别注意。ECMAScript 中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串赋予该变量。要把一个值转化为一个字符串，可以使用 toString() 或 String() 方法。toString() 可以通过指定参数输出二进制、八进制、十六进制，乃至其他任意有效进制格式表示的字符串值。12345678const temp1 = 1;console.log(temp1.toString()); // Output: \"1\"const temp2=0x2A;console.log(temp2.toString(10)); // Output: \"42\"const temp3 = null;console.log(temp3.toString()); // Error: Cannot read property 'toString' of nullconst temp4 = undefined;console.log(temp4.toString()); // Error: Cannot read property 'toString' of null 在不知道要转换的值是不是 null 或 undefined 的情况下，还可以使用转型函数 String() ，这个函数能够将任何类型的值转换为字符串。123console.log(String(10)); // Output: \"10\"console.log(String(null)); // Output: \"null\"console.log(String(undefined)); // Output: \"undefined\" Object类型Object类型表示一组数据或功能的集合，可通过下列语句创建：1const object = new Object(); Object 的每个实例都具有下列属性和方法： constructor：对象的构造器； 12345678function Person(name, sex) &#123; this.name = name; this.sex = sex;&#125;const student = new Person(\"Tom\",\"male\");console.log(student.constructor); // Output: function Person(name,sex) &#123; this.name = name; this.sex = sex; &#125; hasOwnProperty：检查在当前对象实例中是否存在某属性； 12345678function Person(name, sex) &#123; this.name = name; this.sex = sex;&#125;const student = new Person(\"Tom\",\"male\");console.log(student.hasOwnProperty(\"name\")); // Output: trueconsole.log(student.hasOwnProperty(\"grade\")); // Output: false isPrototypeOf(object)：用于检测某对象是否在object的原型链上； 123456789const person = &#123; isHuman: false, printIntroduction: function() &#123; console.log(`My name is $&#123;this.name&#125;. Am I human? $&#123;this.isHuman&#125;`); &#125;&#125;;const me = Object.create(person);console.log(me.isPrototypeOf(person)); // Output: false propertyIsEnumerable(propertyName) ：用于检查给定的属性是否能够使用 for-in 语句，即是否是可迭代的； toLocaleString()：用于返回一个该对象的字符串表示； 123console.log((&#123;&#125;).toLocaleString()); // Output: [object Object]console.log(([1,2]).toLocaleString()); // Output: 1,2console.log((new Date()).toLocaleString()); // Output: 2020/6/16 下午10:07:39 toString()：用于返回对象的字符串表示； valueOf()：返回对象的字符串、数值或布尔值表示。通常与 toString() 方法的返回值相同。 操作符位操作符ECMAScript 中的所有数值都以 IEEE-754 64 位格式存储，但位操作符并不直接操作 64 位的值。而是先将64位的值转换成32位的整数，然后执行操作，最后再将结果转换回 64 位。对于开发人员来说，使用位操作符操作的就是32位整数。默认情况下，ECMAScript 中的所有整数都是有符号整数，32 位中的前 31 位用于表示整数的值第32位用于表示数值的符号（0为正数，1为负数）。正数以纯二进制格式存储，负数以补码形式存储（负数绝对值取反加1）。在 ECMAScript 中，当对数值应用位操作符时，特殊的 NaN 和 Infinity 值都会被当成 0 来处理。如果对非数值应用位操作符，会先使用 Number() 函数将该值转换为一个数值，然后再进行操作。 NOT按位非操作符由 ~ 表示，返回的结果是数值的反码（操作数的负值-1）。 AND按位与操作符由 &amp; 表示，将两个数值的每一位对齐，执行与操作。 OR按位或操作符由 | 表示，将两个数值的每一位对齐，执行或操作。 XOR按位异或操作符由 ^ 表示，将两个数值的每一位对齐，在位上只有一个1时才返回1。 &lt;&lt;左移操作符由 &lt;&lt; 表示，这个操作符会将数值的所有位向左移动指定的位数，以0来填充空位。 &gt;&gt;有符号的右移操作符由 &gt;&gt; 表示，这个操作符会将数值向右移动，但保留符号位（正负不变），并以符号位来填充空位。 &gt;&gt;&gt;无符号右移操作符由 &gt;&gt;&gt; 表示，这个操作符会将数值的所有 32 位都向右移动，并以0来填充空位 相等操作符相等：==/!=以上两个为相等操作符。它们都会先转换操作数的类型，然后再比较它们的相等性： 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值； 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值； 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf() 方法转化后进行比较相等操作符比较时执行的规则： null 和 undefined 相等 在比较相等性之前，不能将 null 和 undefined 转换成其他任何值 如果有一个操作数是 NaN ，则相等操作符返回 false，不相等操作符返回 true，没有例外（NaN不等于自身） 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则返回 true ；否则 false：12345const a = &#123; name: \"tom\"&#125;;const b = &#123; name: \"tom\"&#125;;const c = a;console.log(a == b); // Output:falseconsole.log(a == c); // Output:true 全等： ===/!==全等操作符的比较规则与相等操作符同样，但是它在比较时不会对其进行任何转换。通常为了保持代码中数据类型的完整性，多使用全等操作符。 函数ECMAScript 函数的参数与参数的类型无关，即使传进来的参数与指定的个数或数据类型不同，也不会有问题。之所以会这样，原因是 ECMAScript 中的参数在内部是用一个数组来表示的，在函数体内可以通过 arguments 对象来访问这个参数数组，从而获取传递给函数的每一个参数。arguments数组的长度仅与实际传进来的参数个数有关，与函数事先定义的参数个数无关。arguments 的值永远与对应命名参数的值保持同步。如果修改 arguments 的值，则函数中获取到的参数也会随之改变。但这并不是指 arguments 和函数参数访问了相同的内存空间。它们的内存空间是独立的，但是值是同步的。12345function doAdd(num1, num2) &#123; arguments[1] = 10; console.log(arguments[0] + num2);&#125;doAdd(10, 20); // Output: 10+10=20 因为 ECMAScript 函数的参数与参数的类型无关，所以函数没有重载。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-05-26T12:54:53.717Z","updated":"2019-05-26T12:54:53.718Z","comments":true,"path":"2019/05/26/hello-world/","link":"","permalink":"http://yoursite.com/2019/05/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}